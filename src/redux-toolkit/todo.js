import { createSlice } from "@reduxjs/toolkit";
import produce from "immer";

const initialState = {
    todos: []
}

// In Redux, the state of your whole application is stored in an object tree within a single store.In order to maintain this 
// state and to allow it to be updated, Redux uses reducer functions.However, when the application grows bigger and the state 
// tree becomes larger, managing all of this in one reducer function can become a bit unwieldy.

// That's where the idea of "slicing" comes in. Rather than managing all of your state in a single large reducer, you can split 
// your state tree into "slices," and manage each of these slices with its own reducer.Each slice reducer is responsible for a 
// specific slice of the Redux state tree, and all of the slice reducers are combined together to create the root reducer for 
// the Redux store.This approach can make the code more maintainable and easier to reason about.

// The createSlice function from Redux Toolkit helps with this process.It generates a slice reducer along with corresponding 
// action creators, based on the reducer functions you define.

const todos = createSlice({
    name: 'todos',
    initialState: initialState,
    reducers: {
      addTodo: (state, action) => {
        state.todos = [
            ...state.todos,
            action.payload
        ]
      },
      deleteTodo: (state, action) => {
        state.todos = state.todos.filter(todo => todo.title !== action.payload)
      },
      editTodo: (state, action) => {}
    }
})

// The todos.actions object contains the generated action creators. In this case, addTodo and deleteTodo are action creators
// for adding and deleting todos.
// When you call these functions with an argument, they return an action object with the corresponding action type and payload.
// These action creators can be dispatched to the Redux store to update the state.
// When you define reducers within createSlice, Redux Toolkit is also automatically generating corresponding action creators
// for you. The functions addTodo and deleteTodo that you're destructuring from 'todos.actions' aren't actually the reducers
// you've defined - they're these generated action creators.
// For Example: 
// {
//   type: 'todos/addTodo',
//     payload: 'someTodo'
// }
export const { addTodo, deleteTodo } = todos.actions

// The todos.reducer is the reducer function generated by createSlice. This reducer handles all of the actions defined in the 
// reducers option, and it uses Immer internally to let you write reducers in a simpler way. Instead of returning a new state 
// object, you can write code that mutates the state directly, and Immer will produce a new state based on those mutations.
export default todos.reducer


// What is Immer:
// Immer is a JavaScript package that helps you work with immutable data in a more convenient way. It's based on the
// copy-on-write mechanism. In Redux, when you create a new state in response to an action, you're supposed to make a copy of
// your state and modify it - that is, the state in Redux is immutable.This often leads to a lot of spread(...) operators and //
// can make the code hard to read. For example:

// Without Immer: 
let person = {
  name: "Alice",
  age: 25,
  address: {
    city: "New York",
    country: "USA"
  }
};

let updatedPerson1 = {
  ...person,
  age: 26,
  address: {
    ...person.address,
    city: "Los Angeles"
  }
};

console.log(updatedPerson1);

// With Immer:

// When the function finishes executing, Immer produces the updatedPerson2, where the person includes changed values. The 
// boriginal person remains unchanged.
let updatedPerson2 = produce(person, draftPerson => {
  draftPerson.age = 26;
  draftPerson.address.city = "Los Angeles";
});

console.log(updatedPerson2);